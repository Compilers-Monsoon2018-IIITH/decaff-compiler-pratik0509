%{
        #include <bits/stdc++.h>
        #include "node.h"
        using namespace std;
        extern "C" int yylex();
        extern int yyparse();
        extern union node yylval;
        extern FILE* yyin;
        extern int line_no;
        void yyerror(const char *s);
%}

%token KEY_CLASS KEY_PROGRAM O_COMMA KEY_FOR
%token <str_value> IDENTIFIER
%token <str_value> KEY_TYPE
%token O_SEMICOLON KEY_IF KEY_ELSE KEY_CALLOUT STRING
%token EQUAL_OP ADD_EQUAL_OP SUB_EQUAL_OP
%token LEFT_CBRACE RIGHT_CBRACE INT_LITERAL LEFT_SBRACE RIGHT_SBRACE BOOL_LITERAL CHAR_LITERAL
%token <ival> INT_LITERAL
%token <bval> BOOL_LITERAL
%token <cval> CHAR_LITERAL
%token BINARY_ADD BINARY_SUBTRACT BINARY_MULTIPLY BINARY_DIVISION BINARY_MOD O_LEF O_RIT
%token R_AND R_OR R_EQUALS R_NOT_EQUALS R_GREATER_THAN R_GREATER_THAN_EQUAL R_LESS_THAN R_LESS_THAN_EQUAL
%token UNARY_NOT KEY_RETURN
%token KEY_BREAK KEY_CONTINUE

// Precedence

%right EQUAL_OP ADD_EQUAL_OP SUB_EQUAL_OP
%left R_EQUALS R_NOT_EQUALS
%left R_AND R_OR
%left R_GREATER_THAN R_GREATER_THAN_EQUAL R_LESS_THAN R_LESS_THAN_EQUAL
%left BINARY_ADD BINARY_SUBTRACT
%left BINARY_DIVISION BINARY_MOD BINARY_MULTIPLY
%nonassoc UNARY_NOT

// Non-terminal type declarations
%type <prog> PROGRAM
%type <g_decl> GLOBAL_DECL
// %type <o_semicolons> O_SEMICOLONS
%type <f_decls> FIELD_DECLS
%type <id_list> IDENTIFIER_LIST
%type <m_decls> METHOD_DECLS
%type <blk> BLOCK
%type <exe> EXECUTABLES
%type <v_decl> VAR_DECL
%type <expr> EXPRESSION
// %type <binary_op> BINARY_OP
// %type <arithmetic_op> ARITHMETIC_OP
// %type <relational_op> RELATIONAL_OP
// %type <eq_op> EQ_OP
// %type <conditional_op> CONDITIONAL_OP
%type <lit> LITERAL
// %type <statement> STATEMENT
// %type <else_block> ELSE_BLOCK
%type <m_call> METHOD_CALL
// %type <param_list> PARAM_LIST
// %type <method_name> METHOD_NAME
// %type <assignment_op> ASSIGNMENT_OP
%type <loc> LOCATION
// %type <arg_list> ARG_LIST

%start PROGRAM

%%

PROGRAM: KEY_CLASS KEY_PROGRAM LEFT_CBRACE GLOBAL_DECL RIGHT_CBRACE
                { 
                        $$ = new program();
                        $$->set_global_decl($4);
                }
        ;

GLOBAL_DECL: %empty                     { $$ = new global_decl(); }
            | GLOBAL_DECL FIELD_DECLS   { $$->add_field($2); }
            | GLOBAL_DECL METHOD_DECLS  { $$->add_method($2); }
            ;

O_SEMICOLONS: O_SEMICOLON
        | O_SEMICOLONS O_SEMICOLON
        ;

FIELD_DECLS: KEY_TYPE IDENTIFIER_LIST O_SEMICOLON 
                {
                        $$ = new field_decls();
                        $$->set_field(string($1), $2);
                }
            ;

IDENTIFIER_LIST: IDENTIFIER
                        { $$ = new identifier_list(); $$->add_identifier(new identifier($1));}
                | IDENTIFIER ASSIGNMENT_OP EXPRESSION
                        { $$->add_identifier(new identifier($1)); }
                | IDENTIFIER LEFT_SBRACE INT_LITERAL RIGHT_SBRACE ASSIGNMENT_OP EXPRESSION
                        { $$->add_identifier(new identifier($1)); }
                | IDENTIFIER LEFT_SBRACE INT_LITERAL RIGHT_SBRACE
                        { $$->add_identifier(new identifier($1)); }
                | IDENTIFIER_LIST O_COMMA IDENTIFIER
                        { $$->add_identifier(new identifier($3)); }
                | IDENTIFIER_LIST O_COMMA IDENTIFIER LEFT_SBRACE INT_LITERAL RIGHT_SBRACE
                        { $$->add_identifier(new identifier($3)); }
                ;

METHOD_DECLS: KEY_TYPE IDENTIFIER O_LEF ARG_LIST O_RIT BLOCK
                        { $$ = new method_decls($1, new identifier($2)); }
            ;

BLOCK: LEFT_CBRACE EXECUTABLES RIGHT_CBRACE
                { $$ = new block($2); }
    ;

EXECUTABLES: %empty
                { $$ = new executables(); }
            | EXECUTABLES VAR_DECL 
            | EXECUTABLES STATEMENT 
            | EXECUTABLES O_SEMICOLONS
            ;

VAR_DECL: KEY_TYPE IDENTIFIER_LIST O_SEMICOLON
                { $$ = new var_decl(); $$->set_field($1, $2); }
        ;

EXPRESSION: LOCATION
                { $$ = new expression($1); }
            | METHOD_CALL
                { $$ = new expression($1); }
            | LITERAL
                { $$ = new expression($1); }
            | EXPRESSION BINARY_OP EXPRESSION
            | BINARY_SUBTRACT EXPRESSION
            | BINARY_ADD EXPRESSION
            | UNARY_NOT EXPRESSION
            | O_LEF EXPRESSION O_RIT
            ;

BINARY_OP: ARITHMETIC_OP
        | RELATIONAL_OP
        | EQ_OP
        | CONDITIONAL_OP
        ;

ARITHMETIC_OP: BINARY_ADD
            | BINARY_SUBTRACT
            | BINARY_MULTIPLY
            | BINARY_DIVISION
            | BINARY_MOD
            ;

RELATIONAL_OP: R_LESS_THAN
            | R_GREATER_THAN
            | R_LESS_THAN_EQUAL
            | R_GREATER_THAN_EQUAL
            ;

EQ_OP: R_EQUALS | R_NOT_EQUALS;

CONDITIONAL_OP: R_AND | R_OR;

LITERAL: INT_LITERAL
                { $$ = new literal($1); }
        | BOOL_LITERAL
                { $$ = new literal($1); }
        | CHAR_LITERAL
                { $$ = new literal($1); }
        ;

STATEMENT: LOCATION ASSIGNMENT_OP EXPRESSION O_SEMICOLON
        | METHOD_CALL O_SEMICOLON
        | KEY_IF O_LEF EXPRESSION O_RIT BLOCK
        | KEY_IF O_LEF EXPRESSION O_RIT BLOCK KEY_ELSE ELSE_BLOCK
        | KEY_FOR IDENTIFIER EQUAL_OP EXPRESSION O_COMMA EXPRESSION BLOCK
        | BLOCK
        | KEY_RETURN EXPRESSION O_SEMICOLON
        | KEY_BREAK O_SEMICOLON
        | KEY_CONTINUE O_SEMICOLON
        ;

ELSE_BLOCK: BLOCK
        | KEY_IF O_LEF EXPRESSION O_RIT BLOCK
        | KEY_IF O_LEF EXPRESSION O_RIT BLOCK KEY_ELSE ELSE_BLOCK
        ;

METHOD_CALL: METHOD_NAME O_LEF PARAM_LIST O_RIT { $$ = new method_call(); }
            | KEY_CALLOUT O_LEF STRING O_COMMA PARAM_LIST O_RIT
            ;

PARAM_LIST: %empty
        | EXPRESSION
        | STRING
        | PARAM_LIST O_COMMA EXPRESSION
        | PARAM_LIST O_COMMA STRING
        ;

METHOD_NAME: IDENTIFIER
            ;

ASSIGNMENT_OP: EQUAL_OP
            | ADD_EQUAL_OP
            | SUB_EQUAL_OP
            ;

LOCATION: IDENTIFIER { $$ = new location(); }
        | IDENTIFIER LEFT_SBRACE EXPRESSION RIGHT_SBRACE
        ;

ARG_LIST: %empty
        | KEY_TYPE IDENTIFIER
        | ARG_LIST O_COMMA KEY_TYPE IDENTIFIER
        ;


%%

int main(int argc, char** argv) {
	// Open a file handle to a particular file:
	// FILE *myfile = fopen("test.decaff.file", "r");
	// Make sure it is valid:
	// if (!myfile) {
	// 	printf("I can't open test.decaff.file!\n");
	// 	return -1;
	// }
	// Set Flex to read from it instead of defaulting to STDIN:
	// yyin = myfile;
	
	// Parse through the input:
	yyparse();
	
}

void yyerror(const char *s) {
	// printf("EEK, parse error!  Message: %s\n", s);
        cerr << "Error: Line:" << line_no << " : " << s << endl;
	// might as well halt now:
	exit(-1);
}
